paste("Lin", " YU", sep="")
strsplit("Lin Yu", split = " ")
mix <- c(1, 2, "A")
class(mix)
x <- matrix(1:10, nrow = 2, ncol = 5)
x
t(x)
a <- matrix(11:20, nrow = 2, ncol =5)
rbind(x,a)
cbind(x,a)
a
y <- matrix(1, nrow = 2, ncol = 5)
x * y
z <- t(y)
x %*% z
y
> y <- matrix(11:20, nrow = 2, ncol = 5)
y <- matrix(11:20, nrow = 2, ncol = 5)
x*y
x
y
x%*%y
a <- 1:5
b <- "Lin"
c <- z
out <- list(a = a, b = b, c = c)
out[1]
out[[1]]
out$a
data("iris")
dim(iris)
head(iris)
iris$Sepal.Length
iris[1,2]
x <- rnorm(10, 0 , 1)
plot(1:10, x)
hist(x)
read.csv("/Dropbox/Dunhams/sales.csv")
read.csv("users/annietang/Dropbox/Dunhams/sales.csv")
getwd()
read.csv("/Users/annietang/Dropbox/Dunhams/sales.csv")
source("blind.R") # load the blind search methods
# read D bits from integer x:
binint=function(x,D)
{ x=rev(intToBits(x)[1:D]) # get D bits
# remove extra 0s from raw type:
as.numeric(unlist(strsplit(as.character(x),""))[(1:D)*2])
}
binint=function(x,D)
binint=function(x,D)
{ x=rev(intToBits(x)[1:D]) # get D bits
as.numeric(unlist(strsplit(as.character(x),""))[(1:D)*2])
source("blind.R") # load the blind search methods
binint=function(x,D)
source("blind.R") # load the blind search methods
# read D bits from integer x:
binint=function(x,D)
{ x=rev(intToBits(x)[1:D]) # get D bits
# remove extra 0s from raw type:
as.numeric(unlist(strsplit(as.character(x),""))[(1:D)*2])
}
### blind.R file ###
# full bind search method
#    search - matrix with solutions x D
#    FUN - evaluation function
#    type - "min" or "max"
#    ... - extra parameters for FUN
fsearch=function(search,FUN,type="min",...)
{
x=apply(search,1,FUN,...) # run FUN over all search rows
ib=switch(type,min=which.min(x),max=which.max(x))
return(list(index=ib,sol=search[ib,],eval=x[ib]))
}
# depth-first full search method
#    l - level of the tree
#    b - branch of the tree
#    domain - vector list of size D with domain values
#    FUN - eval function
#    type - "min" or "max"
#    D - dimension (number of variables)
#    x - current solution vector
#    bcur - current best sol
#    ... - extra parameters for FUN
dfsearch=function(l=1,b=1,domain,FUN,type="min",D=length(domain),
x=rep(NA,D),
bcur=switch(type,min=list(sol=NULL,eval=Inf),
max=list(sol=NULL,eval=-Inf)),
...)
{ if((l-1)==D) # "leave" with solution x to be tested:
{ f=FUN(x,...);fb=bcur$eval
ib=switch(type,min=which.min(c(fb,f)),
max=which.max(c(fb,f)))
if(ib==1) return (bcur) else return(list(sol=x,eval=f))
}
else # go through sub branches
{ for(j in 1:length(domain[[l]]))
{ x[l]=domain[[l]][j]
bcur=dfsearch(l+1,j,domain,FUN,type,D=D,
x=x,bcur=bcur,...)
}
return(bcur)
}
}
getwd(
)
setwd('/Users/annietang/Dropbox/NC State/CSC801-002-2018-sp/__scratch/')
getwd()
> source("../_course_lib_r/_course_basic.r")  ; signifDigits(320.001) ; signifDigits(320) ; signifDigits(3.142)
source("../_course_lib_r/_course_basic.r")  ; signifDigits(320.001) ; signifDigits(320) ; signifDigits(3.142)
source("../_course_lib_r/_course_basic.r")  ; file_header("fileTest.txt")
source("../_course_lib_r/_course_basic.r")  ; file_asym_stats("../_course_lib_r/data/fg-asym-pi_needles_test1.txt",  cntProbeLmt=1000, xName="signifDigits", yNames=c("cntProbe", "runtime"))
source("../_course_lib_r/_course_OF_xyz.r") ; pi_newton(2) ;  pi_newton(3) ;  pi_newton(4)  ;  pi_newton(5)
source("../_course_lib_r/_course_OF_xyz.r") ; pi_BPP(3) ; pi_BPP(4) ; pi_BPP(5) ; pi_BPP(15)
source("../_course_lib_r/_course_OF_xyz.r") ; pi_needles(1000)
source("../_course_lib_r/_course_OF_xyz.r") ; pi_darts(1000)
source("../_course_lib_r/_course_xPer_pi.r") ; xPer_pi_needles(10,1215,1000,1, 2:4)
source("../_course_lib_r/_course_xPer_pi.r") ; xPer_pi_needles(10,1215,1000,1, 2:4)
source("../_course_lib_r/_course_xPer_pi.r") ; xPer_pi_BPP(3:17)
source("../_course_lib_r/_course_OF_xyz.r") ; pi_darts(1000)
install plotrix
install.packages(plotrix)
install.packages("plotrix")
source("../_course_lib_r/_course_xPer_pi.r") ; xPer_pi_BPP(3:17)
> source("../_course_lib_r/_course_xPer_pi.r") ; xPer_pi_needles(10,1215,1000,1, 2:4)
source("../_course_lib_r/_course_xPer_pi.r") ; xPer_pi_needles(10,1215,1000,1, 2:4)
source("../_course_lib_r/_course_xPer_pi.r") ; xPer_pi_darts(10,1215,1000,2:4)
install.packages("DEoptim","hash","tools","utils","bazar")
install.packages("DEoptim","hash","tools","utils","bazar")
install.packages("DEoptim","hash","tools","utils","bazar")
install.packages(c("DEoptim","hash","tools","utils","bazar")
)
install.packages(c("DEoptim", "hash", "tools", "utils", "bazar"))
install.packages(c("DEoptim", "hash", "tools", "utils", "bazar"))
install.packages(c("DEoptim", "hash", "tools", "utils", "bazar"))
install.packages(c("DEoptim", "hash", "tools", "utils", "bazar"))
install.packages(c("DEoptim", "hash", "tools", "utils", "bazar"))
install.packages(c("DEoptim", "hash", "tools", "utils", "bazar"))
install.packages(c("DEoptim", "hash", "tools", "utils", "bazar"))
rm(list=ls())
library(hash) ; library(tools) ; library(utils)
OFname = "wild" ; OFpar = 2 ; BKV = 67.467735 ; tolR = 0.005
globPar=hash() ; clear(globPar)
globPar[[paste(sep="", OFname, ".BKV")]]  = BKV
globPar[[paste(sep="", OFname, ".tolR")]] = tolR
print(globPar) ;
test_of_wild = function(x = c(-15.81559, -15.81491, -15.81529)) {
OFname = "wild"
cat("\n.. from test_of_wild: testing objective function with name =", OFname, "\n")
print(globPar)
y = wild(x)
print(cbind(x,y))
return(y)
}
wrap.DEoptim = function(seedInit=-1, OFname="wild", lowerBnd=-50, upperBnd=50,
popSize=64, iterLmt=100, trace=FALSE, OFpar=2, tolR=5e-3)
{
library(DEoptim)
if (seedInit < 0) {seedInit = round(0.5 + 9999*runif(1))} ; set.seed(seedInit)
if (OFpar  > 1)  {
lowerBnd = rep(lowerBnd, OFpar)
upperBnd = rep(upperBnd, OFpar)
}
cat("\nseedInit =", seedInit,
"\nlowerBnd =", lowerBnd,
"\nupperBnd =", upperBnd,
"\niterLmt  =", iterLmt,
"\npopSize  =", popSize,
"\n")
valueTarget = 0 ;# see the normalization of OFname="wild" in this file or under _course_OF_xyz.R
out = DEoptim(fn=OFname, lower=lowerBnd, upper=upperBnd,
DEoptim.control(NP=popSize, itermax=iterLmt, trace=trace, VTR=valueTarget))
return(out)
}
wild = function(x) {
# Copyright 2018: an example from the R package DEoptim-2.2-4
# Extension by Franc Brglez: globPar=hash()
BKV = globPar[["wild.BKV"]]  ;# Best-Known-Value
eps = globPar[["wild.tolR"]]
# x = c(x1, x2, ... , xd)
d   = length(x)
y = sum(10 * sin(0.3 * x) * sin(1.3 * x^2) + 0.00001 * x^4 + 0.2 * x + 80 ) ;# print(y)
if (y < BKV ) {
cat("\n** WARNING from function wild**",
"\n    current BKV =", BKV, "  is NOT the best-known-value",
"\n   better value =", signif(y, 9), "  has been found for x =", signif(x, 9),
"\n")
y = NA
} else if (y - d*BKV <= eps) {
y = 0
} else {
y = y - d*BKV
}
return(y)
# VIGNETTE
# for d=1, this function is an example from the R package DEoptim-2.2-4
# it seems to have a unique best-known-value (BKV = 67.46773) solution at
# x* = -15.81515 not only within [-50, 50] but also up to [-1e5, 1e5]
# seedInit = 5381 ; NP = 64 ; interval = -+ 50000 ; itermax = 200
# > wild(-15.81515537)
# [1] 67.46773489
} # wild
library(hash) ; library(tools) ; library(utils)
wrap.DEoptim = function(seedInit=-1, OFname="wild", lowerBnd=-50, upperBnd=50,
popSize=64, iterLmt=100, trace=FALSE, OFpar=2, tolR=5e-3)
{
library(DEoptim)
if (seedInit < 0) {seedInit = round(0.5 + 9999*runif(1))} ; set.seed(seedInit)
if (OFpar  > 1)  {
lowerBnd = rep(lowerBnd, OFpar)
upperBnd = rep(upperBnd, OFpar)
}
cat("\nseedInit =", seedInit,
"\nlowerBnd =", lowerBnd,
"\nupperBnd =", upperBnd,
"\niterLmt  =", iterLmt,
"\npopSize  =", popSize,
"\n")
valueTarget = 0 ;# see the normalization of OFname="wild" in this file or under _course_OF_xyz.R
out = DEoptim(fn=OFname, lower=lowerBnd, upper=upperBnd,
DEoptim.control(NP=popSize, itermax=iterLmt, trace=trace, VTR=valueTarget))
return(out)
}
# source("../_course_lib_R/_course_wrap_xyz_tmp.R") ; test_of_wild(c(-15.51009, -16.26599, -15.66054)) ; test_of_wild()
# source("../_course_lib_R/_course_wrap_xyz_tmp.R") ; summary(wrap.DEoptim(seedInit=-1, OFname="wild", popSize=64, iterLmt=200, OFpar=2, tolR=5e-3))
# invoke "install.packages(...) before sourcing this file!!!
# install.packages(c("DEoptim", "hash", "tools", "utils", "bazar"))
rm(list=ls())
library(hash) ; library(tools) ; library(utils)
############## These values are "hard-wired for this file only"
OFname = "wild" ; OFpar = 2 ; BKV = 67.467735 ; tolR = 0.005
globPar=hash() ; clear(globPar)
globPar[[paste(sep="", OFname, ".BKV")]]  = BKV
globPar[[paste(sep="", OFname, ".tolR")]] = tolR
print(globPar) ;
test_of_wild = function(x = c(-15.81559, -15.81491, -15.81529)) {
OFname = "wild"
cat("\n.. from test_of_wild: testing objective function with name =", OFname, "\n")
print(globPar)
y = wild(x)
print(cbind(x,y))
return(y)
}
wrap.DEoptim = function(seedInit=-1, OFname="wild", lowerBnd=-50, upperBnd=50,
popSize=64, iterLmt=100, trace=FALSE, OFpar=2, tolR=5e-3)
{
library(DEoptim)
if (seedInit < 0) {seedInit = round(0.5 + 9999*runif(1))} ; set.seed(seedInit)
if (OFpar  > 1)  {
lowerBnd = rep(lowerBnd, OFpar)
upperBnd = rep(upperBnd, OFpar)
}
cat("\nseedInit =", seedInit,
"\nlowerBnd =", lowerBnd,
"\nupperBnd =", upperBnd,
"\niterLmt  =", iterLmt,
"\npopSize  =", popSize,
"\n")
valueTarget = 0 ;# see the normalization of OFname="wild" in this file or under _course_OF_xyz.R
out = DEoptim(fn=OFname, lower=lowerBnd, upper=upperBnd,
DEoptim.control(NP=popSize, itermax=iterLmt, trace=trace, VTR=valueTarget))
return(out)
} ;# wrap.DEoptim
wild = function(x) {
# Copyright 2018: an example from the R package DEoptim-2.2-4
# Extension by Franc Brglez: globPar=hash()
BKV = globPar[["wild.BKV"]]  ;# Best-Known-Value
eps = globPar[["wild.tolR"]]
# x = c(x1, x2, ... , xd)
d   = length(x)
y = sum(10 * sin(0.3 * x) * sin(1.3 * x^2) + 0.00001 * x^4 + 0.2 * x + 80 ) ;# print(y)
if (y < BKV ) {
cat("\n** WARNING from function wild**",
"\n    current BKV =", BKV, "  is NOT the best-known-value",
"\n   better value =", signif(y, 9), "  has been found for x =", signif(x, 9),
"\n")
y = NA
} else if (y - d*BKV <= eps) {
y = 0
} else {
y = y - d*BKV
}
return(y)
# VIGNETTE
# for d=1, this function is an example from the R package DEoptim-2.2-4
# it seems to have a unique best-known-value (BKV = 67.46773) solution at
# x* = -15.81515 not only within [-50, 50] but also up to [-1e5, 1e5]
# seedInit = 5381 ; NP = 64 ; interval = -+ 50000 ; itermax = 200
# > wild(-15.81515537)
# [1] 67.46773489
} # wild
cd
getwd()
setwd
setwd(/Users/annietang/Google\ Drive/CSC801-002-2018-sp/_course_lib_r)
setwd(Users/annietang/Google\ Drive/CSC801-002-2018-sp/_course_lib_r)
setwd("/Users/annietang/Google\ Drive/CSC801-002-2018-sp/_course_lib_r")
rm(list=ls())
library(hash) ; library(tools) ; library(utils)
OFname = "wild" ; OFpar = 2 ; BKV = 67.467735 ; tolR = 0.005
globPar=hash() ; clear(globPar)
globPar[[paste(sep="", OFname, ".BKV")]]  = BKV
globPar[[paste(sep="", OFname, ".tolR")]] = tolR
print(globPar) ;
test_of_wild = function(x = c(-15.81559, -15.81491, -15.81529)) {
OFname = "wild"
cat("\n.. from test_of_wild: testing objective function with name =", OFname, "\n")
print(globPar)
y = wild(x)
print(cbind(x,y))
return(y)
}
wrap.DEoptim = function(seedInit=-1, OFname="wild", lowerBnd=-50, upperBnd=50,
popSize=64, iterLmt=100, trace=FALSE, OFpar=2, tolR=5e-3)
{
library(DEoptim)
if (seedInit < 0) {seedInit = round(0.5 + 9999*runif(1))} ; set.seed(seedInit)
if (OFpar  > 1)  {
lowerBnd = rep(lowerBnd, OFpar)
upperBnd = rep(upperBnd, OFpar)
}
cat("\nseedInit =", seedInit,
"\nlowerBnd =", lowerBnd,
"\nupperBnd =", upperBnd,
"\niterLmt  =", iterLmt,
"\npopSize  =", popSize,
"\n")
valueTarget = 0 ;# see the normalization of OFname="wild" in this file or under _course_OF_xyz.R
out = DEoptim(fn=OFname, lower=lowerBnd, upper=upperBnd,
DEoptim.control(NP=popSize, itermax=iterLmt, trace=trace, VTR=valueTarget))
return(out)
} ;# wrap.DEoptim
wild = function(x) {
# Copyright 2018: an example from the R package DEoptim-2.2-4
# Extension by Franc Brglez: globPar=hash()
BKV = globPar[["wild.BKV"]]  ;# Best-Known-Value
eps = globPar[["wild.tolR"]]
# x = c(x1, x2, ... , xd)
d   = length(x)
y = sum(10 * sin(0.3 * x) * sin(1.3 * x^2) + 0.00001 * x^4 + 0.2 * x + 80 ) ;# print(y)
if (y < BKV ) {
cat("\n** WARNING from function wild**",
"\n    current BKV =", BKV, "  is NOT the best-known-value",
"\n   better value =", signif(y, 9), "  has been found for x =", signif(x, 9),
"\n")
y = NA
} else if (y - d*BKV <= eps) {
y = 0
} else {
y = y - d*BKV
}
return(y)
# VIGNETTE
# for d=1, this function is an example from the R package DEoptim-2.2-4
# it seems to have a unique best-known-value (BKV = 67.46773) solution at
# x* = -15.81515 not only within [-50, 50] but also up to [-1e5, 1e5]
# seedInit = 5381 ; NP = 64 ; interval = -+ 50000 ; itermax = 200
# > wild(-15.81515537)
# [1] 67.46773489
} # wild
setwd("/Users/annietang/Google Drive/CSC801-002-2018-sp/__scratch/")
source("../_course_lib_R/_course_wrap_xyz_tmp.R") ; test_of_wild(c(-15.51009, -16.26599, -15.66054)) ; test_of_wild()
source("../_course_lib_R/_course_wrap_xyz_tmp.R") ; test_of_wild(c(-15.51009, -16.26599, -15.66054)) ; test_of_wild()
out = wrap.DEoptim(popSize=64,  iterLmt=100, OFpar=1) ; summary(out) ;# print(out)
...
out = wrap.DEoptim(popSize=64,  iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
...
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
...
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=3); summary(out) ;# print(out)
...
out = wrap.DEoptim(popSize=256, iterLmt=800, OFpar=3) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=100, OFpar=1) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=3); summary(out) ;# print(out)
out = wrap.DEoptim(popSize=256, iterLmt=800, OFpar=3) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=256, iterLmt=800, OFpar=3) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=256, iterLmt=800, OFpar=3) ; summary(out) ;# print(out)
source("../_course_lib_R/_course_wrap_xyz_tmp.R") ; test_of_wild(c(-15.51009, -16.26599, -15.66054)) ; test_of_wild()
out = wrap.DEoptim(popSize=64,  iterLmt=100, OFpar=1) ; summary(out) ;# print(out)
source("../_course_lib_R/_course_wrap_xyz_tmp.R") ; test_of_wild(c(-15.51009, -16.26599, -15.66054)) ; test_of_wild()
out = wrap.DEoptim(popSize=64,  iterLmt=100, OFpar=1) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=100, OFpar=1) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=100, OFpar=1) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=100, OFpar=1) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=100, OFpar=1) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=100, OFpar=1) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=100, OFpar=1) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=100, OFpar=1) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=100, OFpar=1) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=100, OFpar=1) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=100, OFpar=1) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=3); summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=3); summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=3); summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=3); summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=3); summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=3); summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=3); summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=3); summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=3); summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=3); summary(out) ;# print(out)
out = wrap.DEoptim(popSize=256, iterLmt=800, OFpar=3) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=256, iterLmt=800, OFpar=3) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=256, iterLmt=800, OFpar=3) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=256, iterLmt=800, OFpar=3) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=256, iterLmt=800, OFpar=3) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=256, iterLmt=800, OFpar=3) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=256, iterLmt=800, OFpar=3) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=256, iterLmt=800, OFpar=3) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=256, iterLmt=800, OFpar=3) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=256, iterLmt=800, OFpar=3) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=256, iterLmt=800, OFpar=3) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=256, iterLmt=800, OFpar=3) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=100, OFpar=3) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=100, OFpar=3) ; summary(out) ;# print(out)
...
out = wrap.DEoptim(popSize=64,  iterLmt=100, OFpar=3) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=100, OFpar=3) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=100, OFpar=1) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=128, iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=64,  iterLmt=200, OFpar=2) ; summary(out) ;# print(out)
out = wrap.DEoptim(popSize=256, iterLmt=800, OFpar=3) ; summary(out) ;# print(out)
getwd()
setwd("/Users/annietang/Dropbox/NC State/CSC801-002-2018-sp/__scratch/")
getwd()
######## testing the library _course_basic.r
source("../_course_lib_r/_course_basic.r")  ; signifDigits(320.001) ; signifDigits(320) ; signifDigits(3.142)
source("../_course_lib_r/_course_basic.r")  ; file_header("fileTest.txt")
source("../_course_lib_r/_course_basic.r")  ; file_asym_stats("../_course_lib_r/data/fg-asym-pi_needles_test1.txt",  cntProbeLmt=1000, xName="signifDigits", yNames=c("cntProbe", "runtime"))
######## testing the library _course_OF_xyz.r(continuous Objective Functions)
source("../_course_lib_r/_course_OF_xyz.r") ; pi_newton(2) ;  pi_newton(3) ;  pi_newton(4)  ;  pi_newton(5)
source("../_course_lib_r/_course_OF_xyz.r") ; pi_BPP(3) ; pi_BPP(4) ; pi_BPP(5) ; pi_BPP(15)
source("../_course_lib_r/_course_OF_xyz.r") ; pi_needles(1000)
source("../_course_lib_r/_course_OF_xyz.r") ; pi_darts(1000)
x = c(5, 1, 3)
y = c(-1, 3, 1)
len(x)
length(x)
length(y)
x*y
x.y
x**y
t(x) %*% b
t(x) %*% y
sqrt(sum(x^2))
A = cbind(c(2,1), c(1,1))
print(A)
trace <- function ( A ){
temp = (nrow(A)== nrow(A))
if(temp) {temp = sum(diag(A))}
return(temp) }
A = cbind(c(2,1), c(1,1))
trace(A)
det(A)
solve(A)
A*solve(A)
A*inverseA
inverseA = solve(A) #inverse of A
A*inverseA
A%*%inverseA
eigen(A)
df = read.delim(pipe("pbpaste"))
print(df)
df = read.delim(pipe("pbpaste"))
print(df)
View(df)
df = read(pipe("pbpaste"))
df = read.dcf(pipe("pbpaste"))
df = read.ftable(pipe("pbpaste"))
df = read.table(text=readClipboard(), sep=" ")
df = read.table(text="clipboard", sep=" ", header=TRUE)
print(df)
df = read.table(text="clipboard", sep=" ", header=TRUE)
print(df)
df = read.table(file="clipboard", sep=" ", header=TRUE)
print(df)
load("psych")
install.packages("psych")
df = read.delim(pipe("pbpaste"), sep=" ", header=TRUE)
